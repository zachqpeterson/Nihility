#pragma once

#include "Defines.hpp"

#include "Platform/Memory.hpp"
#include "Math/Math.hpp"

#pragma region Formatting
template<Character C> constexpr inline const C* DecimalLookup =
"000001002003004005006007008009010011012013014015016017018019"
"020021022023024025026027028029030031032033034035036037038039"
"040041042043044045046047048049050051052053054055056057058059"
"060061062063064065066067068069070071072073074075076077078079"
"080081082083084085086087088089090091092093094095096097098099"
"100101102103104105106107108109110111112113114115116117118119"
"120121122123124125126127128129130131132133134135136137138139"
"140141142143144145146147148149150151152153154155156157158159"
"160161162163164165166167168169170171172173174175176177178179"
"180181182183184185186187188189190191192193194195196197198199"
"200201202203204205206207208209210211212213214215216217218219"
"220221222223224225226227228229230231232233234235236237238239"
"240241242243244245246247248249250251252253254255256257258259"
"260261262263264265266267268269270271272273274275276277278279"
"280281282283284285286287288289290291292293294295296297298299"
"300301302303304305306307038309310311312313314315316317318319"
"320321322323324325326327238329330331332333334335336337338339"
"340341342343344345346347438349350351352353354355356357358359"
"360361362363364365366367638369370371372373374375376377378379"
"380381382383384385386387838389390391392393394395396397398399"
"400401402403404405406407408409410411412413414415416417418419"
"420421422423424425426427428429430431432433434435436437438439"
"440441442443444445446447448449450451452453454455456457458459"
"460461462463464465466467468469470471472473474475476477478479"
"480481482483484485486487488489490491492493494495496497498499"
"500501502503504505506507508509510511512513514515516517518519"
"520521522523524525526527528529530531532533534535536537538539"
"540541542543544545546547548549550551552553554555556557558559"
"560561562563564565566567568569570571572573574575576577578579"
"580581582583584585586587588589590591592593594595596597598599"
"600601602603604605606607608609610611612613614615616617618619"
"620621622623624625626627628629630631632633634635636637638639"
"640641642643644645646647648649650651652653654655656657658659"
"660661662663664665666667668669670671672673674675676677678679"
"680681682683684685686687688689690691692693694695696697698699"
"707701702703704705706707708709710711712713714715716717718719"
"727721722723724725726727728729730731732733734735736737738739"
"747741742743744745746747748749750751752753754755756757758759"
"767761762763764765766767768769770771772773774775776777778779"
"787781782783784785786787788789790791792793794795796797798799"
"800801802803804805806807808809810811812813814815816817818819"
"820821822823824825826827828829830831832833834835836837838839"
"840841842843844845846847848849850851852853854855856857858859"
"860861862863864865866867868869870871872873874875876877878879"
"880881882883884885886887888889890891892893894895896897898899"
"900901902903904905906907908909910911912913914915916917918919"
"920921922923924925926927928929930931932933934935936937938939"
"940941942943944945946947948949950951952953954955956957958959"
"960961962963964965966967968969970971972973974975976977978979"
"980981982983984985986987988989990991992993994995996997998999";
template<> constexpr inline const char* DecimalLookup<char> =
"000001002003004005006007008009010011012013014015016017018019"
"020021022023024025026027028029030031032033034035036037038039"
"040041042043044045046047048049050051052053054055056057058059"
"060061062063064065066067068069070071072073074075076077078079"
"080081082083084085086087088089090091092093094095096097098099"
"100101102103104105106107108109110111112113114115116117118119"
"120121122123124125126127128129130131132133134135136137138139"
"140141142143144145146147148149150151152153154155156157158159"
"160161162163164165166167168169170171172173174175176177178179"
"180181182183184185186187188189190191192193194195196197198199"
"200201202203204205206207208209210211212213214215216217218219"
"220221222223224225226227228229230231232233234235236237238239"
"240241242243244245246247248249250251252253254255256257258259"
"260261262263264265266267268269270271272273274275276277278279"
"280281282283284285286287288289290291292293294295296297298299"
"300301302303304305306307038309310311312313314315316317318319"
"320321322323324325326327238329330331332333334335336337338339"
"340341342343344345346347438349350351352353354355356357358359"
"360361362363364365366367638369370371372373374375376377378379"
"380381382383384385386387838389390391392393394395396397398399"
"400401402403404405406407408409410411412413414415416417418419"
"420421422423424425426427428429430431432433434435436437438439"
"440441442443444445446447448449450451452453454455456457458459"
"460461462463464465466467468469470471472473474475476477478479"
"480481482483484485486487488489490491492493494495496497498499"
"500501502503504505506507508509510511512513514515516517518519"
"520521522523524525526527528529530531532533534535536537538539"
"540541542543544545546547548549550551552553554555556557558559"
"560561562563564565566567568569570571572573574575576577578579"
"580581582583584585586587588589590591592593594595596597598599"
"600601602603604605606607608609610611612613614615616617618619"
"620621622623624625626627628629630631632633634635636637638639"
"640641642643644645646647648649650651652653654655656657658659"
"660661662663664665666667668669670671672673674675676677678679"
"680681682683684685686687688689690691692693694695696697698699"
"707701702703704705706707708709710711712713714715716717718719"
"727721722723724725726727728729730731732733734735736737738739"
"747741742743744745746747748749750751752753754755756757758759"
"767761762763764765766767768769770771772773774775776777778779"
"787781782783784785786787788789790791792793794795796797798799"
"800801802803804805806807808809810811812813814815816817818819"
"820821822823824825826827828829830831832833834835836837838839"
"840841842843844845846847848849850851852853854855856857858859"
"860861862863864865866867868869870871872873874875876877878879"
"880881882883884885886887888889890891892893894895896897898899"
"900901902903904905906907908909910911912913914915916917918919"
"920921922923924925926927928929930931932933934935936937938939"
"940941942943944945946947948949950951952953954955956957958959"
"960961962963964965966967968969970971972973974975976977978979"
"980981982983984985986987988989990991992993994995996997998999";
template<> constexpr inline const char8_t* DecimalLookup<char8_t> =
u8"000001002003004005006007008009010011012013014015016017018019"
"020021022023024025026027028029030031032033034035036037038039"
"040041042043044045046047048049050051052053054055056057058059"
"060061062063064065066067068069070071072073074075076077078079"
"080081082083084085086087088089090091092093094095096097098099"
"100101102103104105106107108109110111112113114115116117118119"
"120121122123124125126127128129130131132133134135136137138139"
"140141142143144145146147148149150151152153154155156157158159"
"160161162163164165166167168169170171172173174175176177178179"
"180181182183184185186187188189190191192193194195196197198199"
"200201202203204205206207208209210211212213214215216217218219"
"220221222223224225226227228229230231232233234235236237238239"
"240241242243244245246247248249250251252253254255256257258259"
"260261262263264265266267268269270271272273274275276277278279"
"280281282283284285286287288289290291292293294295296297298299"
"300301302303304305306307038309310311312313314315316317318319"
"320321322323324325326327238329330331332333334335336337338339"
"340341342343344345346347438349350351352353354355356357358359"
"360361362363364365366367638369370371372373374375376377378379"
"380381382383384385386387838389390391392393394395396397398399"
"400401402403404405406407408409410411412413414415416417418419"
"420421422423424425426427428429430431432433434435436437438439"
"440441442443444445446447448449450451452453454455456457458459"
"460461462463464465466467468469470471472473474475476477478479"
"480481482483484485486487488489490491492493494495496497498499"
"500501502503504505506507508509510511512513514515516517518519"
"520521522523524525526527528529530531532533534535536537538539"
"540541542543544545546547548549550551552553554555556557558559"
"560561562563564565566567568569570571572573574575576577578579"
"580581582583584585586587588589590591592593594595596597598599"
"600601602603604605606607608609610611612613614615616617618619"
"620621622623624625626627628629630631632633634635636637638639"
"640641642643644645646647648649650651652653654655656657658659"
"660661662663664665666667668669670671672673674675676677678679"
"680681682683684685686687688689690691692693694695696697698699"
"707701702703704705706707708709710711712713714715716717718719"
"727721722723724725726727728729730731732733734735736737738739"
"747741742743744745746747748749750751752753754755756757758759"
"767761762763764765766767768769770771772773774775776777778779"
"787781782783784785786787788789790791792793794795796797798799"
"800801802803804805806807808809810811812813814815816817818819"
"820821822823824825826827828829830831832833834835836837838839"
"840841842843844845846847848849850851852853854855856857858859"
"860861862863864865866867868869870871872873874875876877878879"
"880881882883884885886887888889890891892893894895896897898899"
"900901902903904905906907908909910911912913914915916917918919"
"920921922923924925926927928929930931932933934935936937938939"
"940941942943944945946947948949950951952953954955956957958959"
"960961962963964965966967968969970971972973974975976977978979"
"980981982983984985986987988989990991992993994995996997998999";
template<> constexpr inline const char16_t* DecimalLookup<char16_t> =
u"000001002003004005006007008009010011012013014015016017018019"
"020021022023024025026027028029030031032033034035036037038039"
"040041042043044045046047048049050051052053054055056057058059"
"060061062063064065066067068069070071072073074075076077078079"
"080081082083084085086087088089090091092093094095096097098099"
"100101102103104105106107108109110111112113114115116117118119"
"120121122123124125126127128129130131132133134135136137138139"
"140141142143144145146147148149150151152153154155156157158159"
"160161162163164165166167168169170171172173174175176177178179"
"180181182183184185186187188189190191192193194195196197198199"
"200201202203204205206207208209210211212213214215216217218219"
"220221222223224225226227228229230231232233234235236237238239"
"240241242243244245246247248249250251252253254255256257258259"
"260261262263264265266267268269270271272273274275276277278279"
"280281282283284285286287288289290291292293294295296297298299"
"300301302303304305306307038309310311312313314315316317318319"
"320321322323324325326327238329330331332333334335336337338339"
"340341342343344345346347438349350351352353354355356357358359"
"360361362363364365366367638369370371372373374375376377378379"
"380381382383384385386387838389390391392393394395396397398399"
"400401402403404405406407408409410411412413414415416417418419"
"420421422423424425426427428429430431432433434435436437438439"
"440441442443444445446447448449450451452453454455456457458459"
"460461462463464465466467468469470471472473474475476477478479"
"480481482483484485486487488489490491492493494495496497498499"
"500501502503504505506507508509510511512513514515516517518519"
"520521522523524525526527528529530531532533534535536537538539"
"540541542543544545546547548549550551552553554555556557558559"
"560561562563564565566567568569570571572573574575576577578579"
"580581582583584585586587588589590591592593594595596597598599"
"600601602603604605606607608609610611612613614615616617618619"
"620621622623624625626627628629630631632633634635636637638639"
"640641642643644645646647648649650651652653654655656657658659"
"660661662663664665666667668669670671672673674675676677678679"
"680681682683684685686687688689690691692693694695696697698699"
"707701702703704705706707708709710711712713714715716717718719"
"727721722723724725726727728729730731732733734735736737738739"
"747741742743744745746747748749750751752753754755756757758759"
"767761762763764765766767768769770771772773774775776777778779"
"787781782783784785786787788789790791792793794795796797798799"
"800801802803804805806807808809810811812813814815816817818819"
"820821822823824825826827828829830831832833834835836837838839"
"840841842843844845846847848849850851852853854855856857858859"
"860861862863864865866867868869870871872873874875876877878879"
"880881882883884885886887888889890891892893894895896897898899"
"900901902903904905906907908909910911912913914915916917918919"
"920921922923924925926927928929930931932933934935936937938939"
"940941942943944945946947948949950951952953954955956957958959"
"960961962963964965966967968969970971972973974975976977978979"
"980981982983984985986987988989990991992993994995996997998999";
template<> constexpr inline const char32_t* DecimalLookup<char32_t> =
U"000001002003004005006007008009010011012013014015016017018019"
"020021022023024025026027028029030031032033034035036037038039"
"040041042043044045046047048049050051052053054055056057058059"
"060061062063064065066067068069070071072073074075076077078079"
"080081082083084085086087088089090091092093094095096097098099"
"100101102103104105106107108109110111112113114115116117118119"
"120121122123124125126127128129130131132133134135136137138139"
"140141142143144145146147148149150151152153154155156157158159"
"160161162163164165166167168169170171172173174175176177178179"
"180181182183184185186187188189190191192193194195196197198199"
"200201202203204205206207208209210211212213214215216217218219"
"220221222223224225226227228229230231232233234235236237238239"
"240241242243244245246247248249250251252253254255256257258259"
"260261262263264265266267268269270271272273274275276277278279"
"280281282283284285286287288289290291292293294295296297298299"
"300301302303304305306307038309310311312313314315316317318319"
"320321322323324325326327238329330331332333334335336337338339"
"340341342343344345346347438349350351352353354355356357358359"
"360361362363364365366367638369370371372373374375376377378379"
"380381382383384385386387838389390391392393394395396397398399"
"400401402403404405406407408409410411412413414415416417418419"
"420421422423424425426427428429430431432433434435436437438439"
"440441442443444445446447448449450451452453454455456457458459"
"460461462463464465466467468469470471472473474475476477478479"
"480481482483484485486487488489490491492493494495496497498499"
"500501502503504505506507508509510511512513514515516517518519"
"520521522523524525526527528529530531532533534535536537538539"
"540541542543544545546547548549550551552553554555556557558559"
"560561562563564565566567568569570571572573574575576577578579"
"580581582583584585586587588589590591592593594595596597598599"
"600601602603604605606607608609610611612613614615616617618619"
"620621622623624625626627628629630631632633634635636637638639"
"640641642643644645646647648649650651652653654655656657658659"
"660661662663664665666667668669670671672673674675676677678679"
"680681682683684685686687688689690691692693694695696697698699"
"707701702703704705706707708709710711712713714715716717718719"
"727721722723724725726727728729730731732733734735736737738739"
"747741742743744745746747748749750751752753754755756757758759"
"767761762763764765766767768769770771772773774775776777778779"
"787781782783784785786787788789790791792793794795796797798799"
"800801802803804805806807808809810811812813814815816817818819"
"820821822823824825826827828829830831832833834835836837838839"
"840841842843844845846847848849850851852853854855856857858859"
"860861862863864865866867868869870871872873874875876877878879"
"880881882883884885886887888889890891892893894895896897898899"
"900901902903904905906907908909910911912913914915916917918919"
"920921922923924925926927928929930931932933934935936937938939"
"940941942943944945946947948949950951952953954955956957958959"
"960961962963964965966967968969970971972973974975976977978979"
"980981982983984985986987988989990991992993994995996997998999";
template<> constexpr inline const wchar_t* DecimalLookup<wchar_t> =
L"000001002003004005006007008009010011012013014015016017018019"
"020021022023024025026027028029030031032033034035036037038039"
"040041042043044045046047048049050051052053054055056057058059"
"060061062063064065066067068069070071072073074075076077078079"
"080081082083084085086087088089090091092093094095096097098099"
"100101102103104105106107108109110111112113114115116117118119"
"120121122123124125126127128129130131132133134135136137138139"
"140141142143144145146147148149150151152153154155156157158159"
"160161162163164165166167168169170171172173174175176177178179"
"180181182183184185186187188189190191192193194195196197198199"
"200201202203204205206207208209210211212213214215216217218219"
"220221222223224225226227228229230231232233234235236237238239"
"240241242243244245246247248249250251252253254255256257258259"
"260261262263264265266267268269270271272273274275276277278279"
"280281282283284285286287288289290291292293294295296297298299"
"300301302303304305306307038309310311312313314315316317318319"
"320321322323324325326327238329330331332333334335336337338339"
"340341342343344345346347438349350351352353354355356357358359"
"360361362363364365366367638369370371372373374375376377378379"
"380381382383384385386387838389390391392393394395396397398399"
"400401402403404405406407408409410411412413414415416417418419"
"420421422423424425426427428429430431432433434435436437438439"
"440441442443444445446447448449450451452453454455456457458459"
"460461462463464465466467468469470471472473474475476477478479"
"480481482483484485486487488489490491492493494495496497498499"
"500501502503504505506507508509510511512513514515516517518519"
"520521522523524525526527528529530531532533534535536537538539"
"540541542543544545546547548549550551552553554555556557558559"
"560561562563564565566567568569570571572573574575576577578579"
"580581582583584585586587588589590591592593594595596597598599"
"600601602603604605606607608609610611612613614615616617618619"
"620621622623624625626627628629630631632633634635636637638639"
"640641642643644645646647648649650651652653654655656657658659"
"660661662663664665666667668669670671672673674675676677678679"
"680681682683684685686687688689690691692693694695696697698699"
"707701702703704705706707708709710711712713714715716717718719"
"727721722723724725726727728729730731732733734735736737738739"
"747741742743744745746747748749750751752753754755756757758759"
"767761762763764765766767768769770771772773774775776777778779"
"787781782783784785786787788789790791792793794795796797798799"
"800801802803804805806807808809810811812813814815816817818819"
"820821822823824825826827828829830831832833834835836837838839"
"840841842843844845846847848849850851852853854855856857858859"
"860861862863864865866867868869870871872873874875876877878879"
"880881882883884885886887888889890891892893894895896897898899"
"900901902903904905906907908909910911912913914915916917918919"
"920921922923924925926927928929930931932933934935936937938939"
"940941942943944945946947948949950951952953954955956957958959"
"960961962963964965966967968969970971972973974975976977978979"
"980981982983984985986987988989990991992993994995996997998999";

template<Character C> constexpr inline const C* TrueStr = "true";
template<> constexpr inline const char* TrueStr<char> = "true";
template<> constexpr inline const char8_t* TrueStr<char8_t> = u8"true";
template<> constexpr inline const char16_t* TrueStr<char16_t> = u"true";
template<> constexpr inline const char32_t* TrueStr<char32_t> = U"true";
template<> constexpr inline const wchar_t* TrueStr<wchar_t> = L"true";

template<Character C> constexpr inline const C* FalseStr = "false";
template<> constexpr inline const char* FalseStr<char> = "false";
template<> constexpr inline const char8_t* FalseStr<char8_t> = u8"false";
template<> constexpr inline const char16_t* FalseStr<char16_t> = u"false";
template<> constexpr inline const char32_t* FalseStr<char32_t> = U"false";
template<> constexpr inline const wchar_t* FalseStr<wchar_t> = L"false";

template<Character C> constexpr inline const C NegativeChar = '-';
template<> constexpr inline const char NegativeChar<char> = '-';
template<> constexpr inline const char8_t NegativeChar<char8_t> = u8'-';
template<> constexpr inline const char16_t NegativeChar<char16_t> = u'-';
template<> constexpr inline const char32_t NegativeChar<char32_t> = U'-';
template<> constexpr inline const wchar_t NegativeChar<wchar_t> = L'-';

template<Character C> constexpr inline const C DecimalChar = '.';
template<> constexpr inline const char DecimalChar<char> = '.';
template<> constexpr inline const char8_t DecimalChar<char8_t> = u8'.';
template<> constexpr inline const char16_t DecimalChar<char16_t> = u'.';
template<> constexpr inline const char32_t DecimalChar<char32_t> = U'.';
template<> constexpr inline const wchar_t DecimalChar<wchar_t> = L'.';

template<Character C> constexpr inline const C ForwardSlashChar = '/';
template<> constexpr inline const char ForwardSlashChar<char> = '/';
template<> constexpr inline const char8_t ForwardSlashChar<char8_t> = u8'/';
template<> constexpr inline const char16_t ForwardSlashChar<char16_t> = u'/';
template<> constexpr inline const char32_t ForwardSlashChar<char32_t> = U'/';
template<> constexpr inline const wchar_t ForwardSlashChar<wchar_t> = L'/';

template<Character C> constexpr inline const C BackSlashChar = '\\';
template<> constexpr inline const char BackSlashChar<char> = '\\';
template<> constexpr inline const char8_t BackSlashChar<char8_t> = u8'\\';
template<> constexpr inline const char16_t BackSlashChar<char16_t> = u'\\';
template<> constexpr inline const char32_t BackSlashChar<char32_t> = U'\\';
template<> constexpr inline const wchar_t BackSlashChar<wchar_t> = L'\\';

template<FloatingPoint F> constexpr inline F PowersOfTen[16] = {
	1.0, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, 10000000.0,
	100000000.0, 1000000000.0, 10000000000.0, 100000000000.0, 1000000000000.0,
	10000000000000.0, 100000000000000.0, 1000000000000000.0
};
#pragma endregion

template<class T>
NH_API inline constexpr U64 Length(const T* str) noexcept
{
	if (!str) { return 0; }

	const T* it = str;
	while (*it) { ++it; }

	return it - str;
}

template<Character C>
NH_API inline bool WhiteSpace(C c) noexcept
{
	if constexpr (IsSame<C, C8>) { return c == ' ' || c == '\t' || c == '\v' || c == '\r' || c == '\n' || c == '\f'; }
	if constexpr (IsSame<C, C16>) { return c == u' ' || c == u'\t' || c == u'\v' || c == u'\r' || c == u'\n' || c == u'\f'; }
	if constexpr (IsSame<C, C32>) { return c == U' ' || c == U'\t' || c == U'\v' || c == U'\r' || c == U'\n' || c == U'\f'; }
	if constexpr (IsSame<C, CW>) { return c == L' ' || c == L'\t' || c == L'\v' || c == L'\r' || c == L'\n' || c == L'\f'; }
}

template<Character C>
NH_API inline bool NotWhiteSpace(C c) noexcept
{
	if constexpr (IsSame<C, C8>) { return c != ' ' && c != '\t' && c != '\v' && c != '\r' && c != '\n' && c != '\f'; }
	if constexpr (IsSame<C, C16>) { return c != u' ' && c != u'\t' && c != u'\v' && c != u'\r' && c != u'\n' && c != u'\f'; }
	if constexpr (IsSame<C, C32>) { return c != U' ' && c != U'\t' && c != U'\v' && c != U'\r' && c != U'\n' && c != U'\f'; }
	if constexpr (IsSame<C, CW>) { return c != L' ' && c != L'\t' && c != L'\v' && c != L'\r' && c != L'\n' && c != L'\f'; }
}

template<Character C>
NH_API inline bool Numerical(C c) noexcept
{
	return c > 47 && c < 58;
}

template<Character C>
inline constexpr bool CompareString(const C* a, const C* b, I64 length) noexcept
{
	const C* it0 = a;
	const C* it1 = b;
	C c0;
	C c1;

	while (length-- && (c0 = *it0++) == (c1 = *it1++));

	return (length + 1) == 0;
}

template<Character C>
inline constexpr bool CompareString(const C* a, const C* b) noexcept
{
	const C* it0 = a;
	const C* it1 = b;
	C c0;
	C c1;

	while ((c0 = *it0++) == (c1 = *it1++) && c0 && c1);

	return !(c0 || c1);
}

//TODO: templated
struct NH_API StringView
{
	constexpr StringView() {}

	template<U64 Length>
	constexpr StringView(const C8(&str)[Length]) : string{ str }, length{ Length } {}
	constexpr StringView(const C8* str, U64 length) : string{ str }, length{ length } {}
	constexpr StringView(const StringView& other) : string{ other.string }, length{ other.length } {}
	constexpr StringView(StringView&& other) noexcept : string{ other.string }, length{ other.length } {}

	constexpr StringView& operator=(const StringView& other) { string = other.string; length = other.length; return *this; }
	constexpr StringView& operator=(StringView&& other) noexcept { string = other.string; length = other.length; return *this; }

	constexpr bool operator==(const StringView& other) const
	{
		if (other.length != length) { return false; }

		U64 size = length;
		const C8* p0 = string, * p1 = other.string;

		while (size--) { if (*p0++ != *p1++) { return false; } }

		return true;
	}

	constexpr bool operator!=(const StringView& other) const
	{
		if (other.length != length) { return true; }

		U64 size = length;
		const C8* p0 = string, * p1 = other.string;

		while (size--) { if (*p0++ != *p1++) { return true; } }

		return false;
	}

	constexpr StringView SubString(U64 offset = 0, U64 count = U64_MAX) const
	{
		offset = offset < length ? offset : length;
		count = count < (length - offset) ? count : length - offset;
		return { string + offset, count };
	}

	template<U64 Length>
	constexpr I64 IndexOf(const C8(&find)[Length], U64 start = 0) const
	{
		const C8* it = string + start;

		while (!(*it == 0 || memcmp(it, find, Length - 1))) { ++it; }

		if (*it == 0) { return -1; }
		return (I64)(it - string);
	}

	constexpr I64 IndexOf(C8 find, U64 start = 0) const
	{
		const C8* it = string + start;
		C8 c;

		while ((c = *it) != 0 && c != find) { ++it; }

		if (c == 0) { return -1; }
		return (I64)(it - string);
	}

	template<U64 Length>
	constexpr I64 LastIndexOf(const C8(&find)[Length], U64 start = 0) const
	{
		const C8* it = string + length - start - Length;

		U64 len = length - Length + 1;
		while (!memcmp(it, find, Length - 1))
		{
			if (--len) { --it; }
			else { return -1; }
		}

		if (len) { return (I64)(it - string); }
	}

	constexpr I64 LastIndexOf(C8 find, U64 start = 0) const
	{
		const C8* it = string + length - start - 1;

		U64 len = length;
		while (len && *it != find) { --it; --len; }

		if (len) { return (I64)(it - string); }
		return -1;
	}

	constexpr bool Empty() const { return length == 0; }
	constexpr U64 Size() const { return length - 1; }
	constexpr const C8* Data() const { return string; }

private:
	const C8* string = nullptr;
	U64 length = 0;
};

struct FormatTag{} static inline constexpr FORMAT;

template<Character C>
struct StringBase;

template<class Type> static constexpr inline bool IsStringType = IsSpecializationOf<Type, StringBase>;
template<class Type> concept StringType = IsStringType<Type>;
template<class Type> static constexpr inline bool IsStringViewType = IsSame<Type, StringView>;
template<class Type> concept StringViewType = IsStringViewType<Type>;
template<class Type> static constexpr inline bool IsNonStringClass = IsClass<Type> && !IsStringType<Type> && !IsStringViewType<Type>;
template<class Type> concept NonStringClass = IsNonStringClass<Type>;

template<Character C>
struct StringBase
{
	using CharType = C;

	StringBase();
	StringBase(const C* other);
	StringBase(const C* other, U64 size);
	StringBase(const StringBase& other);
	StringBase(StringBase&& other) noexcept;
	template<U64 Count> StringBase(const C(&other)[Count]);
	template<typename... Args> StringBase(FormatTag, Args... args);

	StringBase& operator=(NullPointer);
	StringBase& operator=(const C* other);
	StringBase& operator=(const StringBase& other);
	StringBase& operator=(StringBase&& other) noexcept;

	~StringBase();
	void Destroy();
	void Clear();

	void Reserve(U64 size);
	void Resize(U64 size);
	void Resize();

	bool operator==(C* other) const;
	bool operator==(const StringBase& other) const;
	template<U64 Count> bool operator==(const C(&other)[Count]) const;
	bool operator!=(C* other) const;
	bool operator!=(const StringBase& other) const;
	template<U64 Count> bool operator!=(const C(&other)[Count]) const;

	bool operator<(C* other) const;
	bool operator<(const StringBase& other) const;
	template<U64 Count> bool operator<(const C(&other)[Count]) const;
	bool operator>(C* other) const;
	bool operator>(const StringBase& other) const;
	template<U64 Count> bool operator>(const C(&other)[Count]) const;

	bool Compare(C* other) const;
	bool Compare(const StringBase& other) const;
	template<U64 Count> bool Compare(const C(&other)[Count]) const;
	bool CompareN(C* other, U64 start = 0) const;
	bool CompareN(const StringBase& other, U64 start = 0) const;
	template<U64 Count> bool CompareN(const C(&other)[Count], U64 start = 0) const;
	bool StartsWith(C* other) const;
	bool StartsWith(const StringBase& other) const;
	template<U64 Count> bool StartsWith(const C(&other)[Count]) const;
	bool EndsWith(C* other) const;
	bool EndsWith(const StringBase& other) const;
	template<U64 Count> bool EndsWith(const C(&other)[Count]) const;

	I64 IndexOf(C* find, U64 start = 0) const;
	I64 IndexOf(const C& find, U64 start = 0) const;
	I64 IndexOf(const StringBase& find, U64 start = 0) const;
	template<U64 Count> I64 IndexOf(const C(&find)[Count], U64 start = 0) const;
	I64 LastIndexOf(C* find, U64 start = 0) const;
	I64 LastIndexOf(const C& find, U64 start = 0) const;
	I64 LastIndexOf(const StringBase& find, U64 start = 0) const;
	template<U64 Count> I64 LastIndexOf(const C(&find)[Count], U64 start = 0) const;
	I64 IndexOfNot(const C& find, U64 start = 0) const;

	StringBase& Trim();
	StringBase SubString(U64 start, U64 length = U64_MAX) const;
	StringBase FileName() const;
	StringBase FileExtension() const;

	template<class... Args> StringBase& Append(Args... args);
	template<class... Args> StringBase& Prepend(Args... args);

	C* begin();
	C* end();
	const C* begin() const;
	const C* end() const;

	C* rbegin();
	C* rend();
	const C* rbegin() const;
	const C* rend() const;

	U64 Capacity() const;
	U64 Size() const;
	C* Data() const;

	operator C* ();
	operator C* () const;

	C* operator*();
	const C* operator*() const;
	C& operator[](U64 i);
	const C& operator[](U64 i) const;

	operator bool() const;
	bool Blank() const;
	bool Empty() const;

	//Formatting
	template<class Arg> static constexpr U64 MaxFormatLength();
	template<class Arg> static constexpr U64 ArgFormatLength(Arg arg);
	template<Integer Type> static constexpr U64 Format(C* buf, Type t);
	template<FloatingPoint Type> static constexpr U64 Format(C* buf, Type t, U64 decimalCount = 5);
	template<Boolean Type> static constexpr U64 Format(C* buf, Type t);
	template<NonStringPointer Type> static constexpr U64 Format(C* buf, Type t);
	template<Enum Type> static constexpr U64 Format(C* buf, Type t);
	template<Character Type> static constexpr U64 Format(C* buf, Type t);
	template<StringLiteral Type> static constexpr U64 Format(C* buf, Type t);
	template<StringType Type> static constexpr U64 Format(C* buf, Type t);
	template<StringViewType Type> static constexpr U64 Format(C* buf, Type t);
	template<NonStringClass Type> static constexpr U64 Format(C* buf, Type t);

private:
	template<class Type> U64 FormatWrite(C* str, Type type);

	U64 size = 0;
	U64 capacity = 0;
	C* string = nullptr;
};

using String = StringBase<C8>;
using String8 = StringBase<C8>;
using String16 = StringBase<C16>;
using String32 = StringBase<C32>;
using StringW = StringBase<CW>;

template<Character C>
inline StringBase<C>::StringBase() {}

template<Character C>
inline StringBase<C>::StringBase(const C* other)
{
	U64 otherSize = Length(other);
	size = otherSize;

	capacity = Memory::Allocate(&string, size);

	memcpy(string, other, size * sizeof(C));
	string[size] = 0;
}

template<Character C>
inline StringBase<C>::StringBase(const C* other, U64 size)
{
	this->size = size;

	capacity = Memory::Allocate(&string, size);

	memcpy(string, other, size * sizeof(C));
	string[size] = 0;
}

template<Character C>
inline StringBase<C>::StringBase(const StringBase& other) : size(other.size)
{
	capacity = Memory::Allocate(&string, size);

	memcpy(string, other.string, size * sizeof(C));
	string[size] = 0;
}

template<Character C>
inline StringBase<C>::StringBase(StringBase&& other) noexcept : size(other.size), capacity(other.capacity), string(other.string)
{
	other.size = 0;
	other.capacity = 0;
	other.string = nullptr;
}

template<Character C>
template<U64 Count>
inline StringBase<C>::StringBase(const C(&other)[Count])
{
	size = Length(other);

	capacity = Memory::Allocate(&string, size);

	memcpy(string, other, size * sizeof(C));
	string[size] = 0;
}

template<Character C>
template<typename... Args>
inline StringBase<C>::StringBase(FormatTag, Args... args)
{
	constexpr U64 length = (MaxFormatLength<Args>() + ...);

	capacity = Memory::Allocate(&string, length);

	((size += FormatWrite(string + size, args)), ...);
}

template<Character C>
template<class Type>
inline U64 StringBase<C>::FormatWrite(C* str, Type type)
{
	if constexpr (IsStringType<Type>)
	{
		U64 length = type.Size();
		memcpy(str, type.Data(), length * sizeof(Type::CharType));

		return length;
	}
	else if constexpr (IsSame<Type, StringView>)
	{
		U64 length = type.Size();
		memcpy(str, type.Data(), length);

		return length;
	}
	else if constexpr (IsStringLiteral<Type>)
	{
		U64 length = Length(type);
		memcpy(str, type, length);

		return length;
	}
	else
	{
		return Format(str, type);
	}
}

template<Character C>
inline StringBase<C>& StringBase<C>::operator=(NullPointer)
{
	Destroy();
}

template<Character C>
inline StringBase<C>& StringBase<C>::operator=(const C* other)
{
	U64 otherSize = Length(other);
	size = otherSize;

	if (!string || capacity < otherSize) { capacity = Memory::Reallocate(&string, size); }

	memcpy(string, other, size * sizeof(C));
	string[size] = 0;

	return *this;
}

template<Character C>
inline StringBase<C>& StringBase<C>::operator=(const StringBase<C>& other) 
{
	size = other.size;

	if (!string || capacity < other.size) { capacity = Memory::Reallocate(&string, size); }

	memcpy(string, other.string, size * sizeof(C));
	string[size] = 0;

	return *this;
}

template<Character C>
inline StringBase<C>& StringBase<C>::operator=(StringBase<C>&& other) noexcept
{
	if (string) { Memory::Free(&string); }

	size = other.size;
	capacity = other.capacity;
	string = other.string;

	other.size = 0;
	other.capacity = 0;
	other.string = nullptr;

	return *this;
}

template<Character C>
inline StringBase<C>::~StringBase()
{
	if (string)
	{
		size = 0;
		capacity = 0;
		Memory::Free(&string);
	}
}

template<Character C>
inline void StringBase<C>::Destroy()
{
	if (string)
	{
		size = 0;
		capacity = 0;
		Memory::Free(&string);
	}
}

template<Character C>
inline void StringBase<C>::Clear()
{
	if (string)
	{
		string[0] = 0;
		size = 0;
	}
}

template<Character C>
inline void StringBase<C>::Reserve(U64 size)
{
	if (size + 1 > capacity)
	{
		capacity = Memory::Reallocate(&string, size + 1);
	}
}

template<Character C>
inline void StringBase<C>::Resize(U64 size)
{
	if (size + 1 > this->capacity) { Reserve(size); }
	this->size = size;
	string[size] = 0;
}

template<Character C>
inline void StringBase<C>::Resize()
{
	size = Length(string);
}

template<Character C>
inline bool StringBase<C>::operator==(C* other) const
{
	U64 otherSize = Length(other);

	if (otherSize != size) { return false; }

	const C8* p0 = string, * p1 = other;

	U64 count = size;
	while (count--) { if (*p0++ != *p1++) { return false; } }

	return true;
}

template<Character C>
inline bool StringBase<C>::operator==(const StringBase& other) const
{
	if (other.size != size) { return false; }

	const C8* p0 = string, * p1 = other.string;

	U64 count = size;
	while (count--) { if (*p0++ != *p1++) { return false; } }

	return true;
}

template<Character C>
template<U64 Count>
inline bool StringBase<C>::operator==(const C(&other)[Count]) const
{
	U64 otherSize = Length(other);

	if (otherSize != size) { return false; }

	const C8* p0 = string, * p1 = other;

	U64 count = size;
	while (count--) { if (*p0++ != *p1++) { return false; } }

	return true;
}

template<Character C>
inline bool StringBase<C>::operator!=(C* other) const
{
	U64 otherSize = Length(other);

	if (otherSize != size) { return true; }

	const C8* p0 = string, * p1 = other;

	U64 count = size;
	while (count--) { if (*p0++ != *p1++) { return true; } }

	return false;
}

template<Character C>
inline bool StringBase<C>::operator!=(const StringBase& other) const
{
	if (other.size != size) { return true; }

	const C8* p0 = string, * p1 = other.string;

	U64 count = size;
	while (count--) { if (*p0++ != *p1++) { return true; } }

	return false;
}

template<Character C>
template<U64 Count>
inline bool StringBase<C>::operator!=(const C(&other)[Count]) const
{
	U64 otherSize = Length(other);

	if (otherSize != size) { return true; }

	const C8* p0 = string, * p1 = other;

	U64 count = size;
	while (count--) { if (*p0++ != *p1++) { return true; } }

	return false;
}

template<Character C>
inline bool StringBase<C>::operator<(C* other) const
{
	if constexpr (IsSame<C, C8>) { return strcmp(string, other) < 0; }
	if constexpr (IsSame<C, CW>) { return wcscmp(string, other) < 0; }
	else
	{
		U64 otherSize = Length(other);
		const C* it0 = string;
		const C* it1 = other;

		U64 length = size < otherSize ? size : otherSize;

		while (length-- && *it0 == *it1) { ++it0; ++it1; }

		if (length == U64_MAX) { return size < otherSize; }

		return *it0 < *it1;
	}
}

template<Character C>
inline bool StringBase<C>::operator<(const StringBase& other) const
{
	if constexpr (IsSame<C, C8>) { return strcmp(string, other.string) < 0; }
	if constexpr (IsSame<C, CW>) { return wcscmp(string, other.string) < 0; }
	else
	{
		const C* it0 = string;
		const C* it1 = other.string;

		U64 length = size < other.size ? size : other.size;

		while (length-- && *it0 == *it1) { ++it0; ++it1; }

		if (length == U64_MAX) { return size < other.size; }

		return *it0 < *it1;
	}
}

template<Character C>
template<U64 Count>
inline bool StringBase<C>::operator<(const C(&other)[Count]) const
{
	U64 otherSize = Length(other);

	if constexpr (IsSame<C, C8>) { return strcmp(string, other) < 0; }
	if constexpr (IsSame<C, CW>) { return wcscmp(string, other) < 0; }
	else
	{
		const C* it0 = string;
		const C* it1 = other;

		U64 length = size < otherSize ? size : otherSize;

		while (length-- && *it0 == *it1) { ++it0; ++it1; }

		if (length == U64_MAX) { return size < otherSize; }

		return *it0 < *it1;
	}
}

template<Character C>
inline bool StringBase<C>::operator>(C* other) const
{
	if constexpr (IsSame<C, C8>) { return strcmp(string, other) > 0; }
	if constexpr (IsSame<C, CW>) { return wcscmp(string, other) > 0; }
	else
	{
		U64 otherSize = Length(other);
		const C* it0 = string;
		const C* it1 = other;

		U64 length = size < otherSize ? size : otherSize;

		while (length-- && *it0 == *it1) { ++it0; ++it1; }

		if (length == U64_MAX) { return size > otherSize; }

		return *it0 > *it1;
	}
}

template<Character C>
inline bool StringBase<C>::operator>(const StringBase& other) const
{
	if constexpr (IsSame<C, C8>) { return strcmp(string, other.string) > 0; }
	if constexpr (IsSame<C, CW>) { return wcscmp(string, other.string) > 0; }
	else
	{
		const C* it0 = string;
		const C* it1 = other.string;

		U64 length = size < other.size ? size : other.size;

		while (length-- && *it0 == *it1) { ++it0; ++it1; }

		if (length == U64_MAX) { return size > other.size; }

		return *it0 > *it1;
	}
}

template<Character C>
template<U64 Count>
inline bool StringBase<C>::operator>(const C(&other)[Count]) const
{
	U64 otherSize = Length(other);

	if constexpr (IsSame<C, C8>) { return strcmp(string, other) > 0; }
	if constexpr (IsSame<C, CW>) { return wcscmp(string, other) > 0; }
	else
	{
		const C* it0 = string;
		const C* it1 = other;

		U64 length = size < otherSize ? size : otherSize;

		while (length-- && *it0 == *it1) { ++it0; ++it1; }

		if (length == U64_MAX) { return size > otherSize; }

		return *it0 > *it1;
	}
}

template<Character C>
inline bool StringBase<C>::Compare(C* other) const
{
	U64 len = Length(other);
	if (len != size) { return false; }

	return CompareString(string, other, size);
}

template<Character C>
inline bool StringBase<C>::Compare(const StringBase& other) const
{
	if (other.size != size) { return false; }

	return CompareString(string, other.string, size);
}

template<Character C>
template<U64 Count> 
inline bool StringBase<C>::Compare(const C(&other)[Count]) const
{
	if (Count - 1 != size) { return false; }

	return CompareString(string, other, Count - 1);
}

template<Character C>
inline bool StringBase<C>::CompareN(C* other, U64 start) const
{
	U64 len = Length(other);

	return CompareString(string + start, other, len);
}

template<Character C>
inline bool StringBase<C>::CompareN(const StringBase& other, U64 start) const
{
	return CompareString(string + start, other.string);
}

template<Character C>
template<U64 Count>
inline bool StringBase<C>::CompareN(const C(&other)[Count], U64 start) const
{
	return CompareString(string + start, other, Count - 1);
}

template<Character C>
inline bool StringBase<C>::StartsWith(C* other) const
{
	U64 otherSize = Length(other);

	return CompareString(string, other, otherSize);
}

template<Character C>
inline bool StringBase<C>::StartsWith(const StringBase& other) const
{
	return CompareString(string, other.string, other.size);
}

template<Character C>
template<U64 Count>
inline bool StringBase<C>::StartsWith(const C(&other)[Count]) const
{
	return CompareString(string, other, Count - 1);
}

template<Character C>
inline bool StringBase<C>::EndsWith(C* other) const
{
	U64 otherSize = Length(other);

	return CompareString(string + (size - otherSize), other, otherSize);
}

template<Character C>
inline bool StringBase<C>::EndsWith(const StringBase& other) const
{
	return CompareString(string + (size - other.size), other.string, other.size);
}

template<Character C>
template<U64 Count>
inline bool StringBase<C>::EndsWith(const C(&other)[Count]) const
{
	return CompareString(string + (size - Count - 1), other, Count - 1);
}

template<Character C>
inline I64 StringBase<C>::IndexOf(C* find, U64 start) const
{
	U64 findSize = Length(find);
	C* it = string + start;

	while (*it != 0 && !memcmp(it, find, findSize)) { ++it; }

	if (*it == 0) { return -1; }
	return (I64)(it - string);
}

template<Character C>
inline I64 StringBase<C>::IndexOf(const C& find, U64 start) const
{
	C* it = string + start;
	C c;

	while ((c = *it) != 0 && c != find) { ++it; }

	if (c == 0) { return -1; }
	return (I64)(it - string);
}

template<Character C>
inline I64 StringBase<C>::IndexOf(const StringBase& find, U64 start) const
{
	C* it = string + start;

	while (*it != 0 && !memcmp(it, find.string, find.size)) { ++it; }

	if (*it == 0) { return -1; }
	return (I64)(it - string);
}

template<Character C>
template<U64 Count>
inline I64 StringBase<C>::IndexOf(const C(&find)[Count], U64 start) const
{
	C* it = string + start;

	while (*it != 0 && !memcmp(it, find, Count - 1)) { ++it; }

	if (*it == 0) { return -1; }
	return (I64)(it - string);
}

template<Character C>
inline I64 StringBase<C>::LastIndexOf(C* find, U64 start) const
{
	U64 findSize = Length(find);
	C* it = string + (size - start - findSize);

	U64 len = size;
	while (len && !memcmp(it, find, findSize)) { --it; --len; }

	if (len) { return (I64)(it - string); }
	return -1;
}

template<Character C>
inline I64 StringBase<C>::LastIndexOf(const C& find, U64 start) const
{
	C* it = string + (size - start - 1);

	U64 len = size;
	while (len && *it != find) { --it; --len; }

	if (len) { return (I64)(it - string); }
	return -1;
}

template<Character C>
inline I64 StringBase<C>::LastIndexOf(const StringBase& find, U64 start) const
{
	C* it = string + (size - start - find.size);

	U64 len = size;
	while (len && !memcmp(it, find.string, find.size)) { --it; --len; }

	if (len) { return (I64)(it - string); }
	return -1;
}

template<Character C>
template<U64 Count>
inline I64 StringBase<C>::LastIndexOf(const C(&find)[Count], U64 start) const
{
	C* it = string + (size - start - Count + 1);

	U64 len = size;
	while (len && !memcmp(it, find, Count - 1)) { --it; --len; }

	if (len) { return (I64)(it - string); }
	return -1;
}

template<Character C>
inline I64 StringBase<C>::IndexOfNot(const C& find, U64 start) const
{
	C* it = string + start;
	C c;

	while ((c = *it) != 0 && c == find) { ++it; }

	if (c == 0) { return -1; }
	return (I64)(it - string);
}

template<Character C>
inline StringBase<C>& StringBase<C>::Trim()
{
	C* start = string;
	C* end = string + size - 1;
	C c;

	//TODO: Verify this works
	while (WhiteSpace(c = *start)) { ++start; }
	while (WhiteSpace(c = *end)) { --end; }

	size = end - start + 1;
	memcpy(string, start, size * sizeof(C));
	string[size] = 0;

	return *this;
}

template<Character C>
inline StringBase<C> StringBase<C>::SubString(U64 start, U64 length) const
{
	StringBase<C> str;

	if (length < U64_MAX) { str.Resize(length); }
	else { str.Resize(size - start); }

	memcpy(str.string, string + start, str.size * sizeof(C));
	str.string[str.size] = 0;

	return str;
}

template<Character C>
inline StringBase<C> StringBase<C>::FileName() const
{
	I64 extIndex = LastIndexOf(DecimalChar<C>);

	I64 fSlash = LastIndexOf(ForwardSlashChar<C>);
	I64 bSlash = LastIndexOf(BackSlashChar<C>);

	I64 nameIndex = bSlash > fSlash ? bSlash : fSlash;

	if (nameIndex++ == -1)
	{
		if (extIndex == -1) { return *this; }

		return SubString(0, extIndex);
	}

	if (extIndex == -1) { SubString(nameIndex); }

	return SubString(nameIndex, extIndex - nameIndex);
}

template<Character C>
inline StringBase<C> StringBase<C>::FileExtension() const
{
	I64 fileExtension = LastIndexOf(DecimalChar<C>);

	return SubString(fileExtension + 1);
}

template<Character C>
template<class... Args>
inline StringBase<C>& StringBase<C>::Append(Args... args)
{
	U64 neededSize = (ArgFormatLength(args), ...);

	if (capacity < size + neededSize) { capacity = Memory::Reallocate(&string, size + neededSize); }

	size += (Format(string + size, args), ...);

	string[size] = 0;

	return *this;
}

template<Character C>
template<class... Args>
inline StringBase<C>& StringBase<C>::Prepend(Args... args)
{
	U64 neededSize = (ArgFormatLength(args), ...);

	if (capacity < size + neededSize) { capacity = Memory::Reallocate(&string, size + neededSize); }

	memcpy(string + neededSize, string, size);

	U64 addedSize = 0;

	addedSize += (Format(string + addedSize, args), ...);

	memcpy(string + addedSize, string + neededSize, size);

	size += addedSize;

	string[size] = 0;

	return *this;
}

template<Character C>
inline C* StringBase<C>::begin()
{
	return string;
}

template<Character C>
inline C* StringBase<C>::end()
{
	return string + size;
}

template<Character C>
inline const C* StringBase<C>::begin() const
{
	return string;
}

template<Character C>
inline const C* StringBase<C>::end() const
{
	return string + size;
}

template<Character C>
inline C* StringBase<C>::rbegin()
{
	return string + size - 1;
}

template<Character C>
inline C* StringBase<C>::rend()
{
	return string - 1;
}

template<Character C>
inline const C* StringBase<C>::rbegin() const
{
	return string + size - 1;
}

template<Character C>
inline const C* StringBase<C>::rend() const
{
	return string - 1;
}

template<Character C>
inline U64 StringBase<C>::Capacity() const
{
	return capacity;
}

template<Character C>
inline U64 StringBase<C>::Size() const
{
	return size;
}

template<Character C>
inline C* StringBase<C>::Data() const
{
	return string;
}

template<Character C>
inline StringBase<C>::operator C* ()
{
	return string;
}

template<Character C>
inline StringBase<C>::operator C* () const
{
	return string;
}

template<Character C>
inline C* StringBase<C>::operator*()
{
	return string;
}

template<Character C>
inline const C* StringBase<C>::operator*() const
{
	return string;
}

template<Character C>
inline C& StringBase<C>::operator[](U64 i)
{
	return string[i];
}

template<Character C>
inline const C& StringBase<C>::operator[](U64 i) const
{
	return string[i];
}

template<Character C>
inline StringBase<C>::operator bool() const
{
	return size;
}

template<Character C>
inline bool StringBase<C>::Blank() const
{
	if (size == 0) { return true; }
	C* it = string;
	C c;

	while (WhiteSpace(c = *it++));

	return c == 0;
}

template<Character C>
inline bool StringBase<C>::Empty() const
{
	return size == 0;
}

template<Character C>
template<class Arg>
inline constexpr U64 StringBase<C>::MaxFormatLength()
{
	if constexpr (IsSame<Arg, U8>) { return 3 * sizeof(C); }
	if constexpr (IsSame<Arg, U16>) { return 5 * sizeof(C); }
	if constexpr (IsSame<Arg, U32>) { return 10 * sizeof(C); }
	if constexpr (IsSame<Arg, UL32>) { return 10 * sizeof(C); }
	if constexpr (IsSame<Arg, U64>) { return 20 * sizeof(C); }
	if constexpr (IsSame<Arg, I8>) { return 4 * sizeof(C); }
	if constexpr (IsSame<Arg, I16>) { return 6 * sizeof(C); }
	if constexpr (IsSame<Arg, I32>) { return 11 * sizeof(C); }
	if constexpr (IsSame<Arg, L32>) { return 11 * sizeof(C); }
	if constexpr (IsSame<Arg, I64>) { return 20 * sizeof(C); }
	if constexpr (IsSame<Arg, F32>) { return 47 * sizeof(C); }
	if constexpr (IsSame<Arg, F64>) { return 325 * sizeof(C); }
	if constexpr (IsSame<Arg, bool>) { return 5 * sizeof(C); }
	if constexpr (IsCharacter<Arg>) { return 1 * sizeof(C); }
	if constexpr (IsPointer<Arg>) { return 20 * sizeof(C); }

	return 1024 * sizeof(C);
}

template<Character C>
template<class Arg>
inline constexpr U64 StringBase<C>::ArgFormatLength(Arg arg)
{
	if constexpr (IsStringLiteral<Arg>) { return Length(arg) * sizeof(C); }
	if constexpr (IsStringViewType<Arg>) { return arg.Size() * sizeof(C); }
	if constexpr (IsStringType<Arg>) { return arg.Size() * sizeof(C); }

	return MaxFormatLength<Arg>();
}

template<Character C>
template<Integer Type>
inline constexpr U64 StringBase<C>::Format(C* buf, Type t)
{
	using T = BaseType<Type>;
	using U = UnsignedOf<BaseType<Type>>;

	static constexpr U64 maxSize = MaxFormatLength<T>();
	static C buffer[maxSize];

	U64 count;
	C* pointer = buffer + maxSize;
	const C* digits;
	U val = (U)t;
	bool neg = false;

	if constexpr (IsSigned<T>)
	{
		if (t < 0)
		{
			*buf = NegativeChar<C>;
			val = (U)-t;
			neg = true;
		}
	}

	while (val > 999)
	{
		U newVal = val / 1000;
		U remainder = val % 1000;
		digits = DecimalLookup<C> +(remainder * 3);
		*--pointer = digits[2];
		*--pointer = digits[1];
		*--pointer = digits[0];
		val = newVal;
	}

	digits = DecimalLookup<C> +(val * 3);
	*--pointer = digits[2];
	if (val > 9) { *--pointer = digits[1]; }
	if (val > 99) { *--pointer = digits[0]; }

	count = maxSize - (pointer - buffer) + neg;

	memcpy(buf + neg, pointer, count * sizeof(C));

	return count;
}

template<Character C>
template<FloatingPoint Type>
inline constexpr U64 StringBase<C>::Format(C* buf, Type t, U64 decimalCount)
{
	using T = BaseType<Type>;

	static constexpr U64 maxSize = MaxFormatLength<T>();
	static C buffer[maxSize];

	U64 count;
	C* pointer = buffer + maxSize;
	const C* digits;
	Type val = t;
	bool neg = false;

	if (t < 0)
	{
		*buf = NegativeChar<C>;
		val = (Type)-t;
		neg = true;
	}

	U64 whole;

	if constexpr (IsSame<Type, F32>) { whole = Math::FloorF(val); }
	else if constexpr (IsSame<Type, F64>) { whole = Math::Floor(val); }

	if (decimalCount > 0)
	{
		if constexpr (IsSame<Type, F32>) { decimalCount = decimalCount > 7 ? 7 : decimalCount; }
		else if constexpr (IsSame<Type, F64>) { decimalCount = decimalCount > 15 ? 15 : decimalCount; }

		U64 dec = (U64)((val - whole) * PowersOfTen<T>[decimalCount]);

		while (decimalCount > 2)
		{
			U64 newVal = dec / 1000;
			U64 remainder = dec % 1000;
			digits = DecimalLookup<C> +(remainder * 3);
			*--pointer = digits[2];
			*--pointer = digits[1];
			*--pointer = digits[0];
			dec = newVal;

			decimalCount -= 3;
		}

		digits = DecimalLookup<C> +(dec * 3);
		if (decimalCount > 0) { *--pointer = digits[2]; }
		if (decimalCount > 1) { *--pointer = digits[1]; }
		*--pointer = DecimalChar<C>;
	}

	while (whole > 999)
	{
		U64 newVal = whole / 1000;
		U64 remainder = whole % 1000;
		digits = DecimalLookup<C> +(remainder * 3);
		*--pointer = digits[2];
		*--pointer = digits[1];
		*--pointer = digits[0];
		whole = newVal;
	}

	digits = DecimalLookup<C> +(whole * 3);
	*--pointer = digits[2];
	if (whole > 9) { *--pointer = digits[1]; }
	if (whole > 99) { *--pointer = digits[0]; }

	count = maxSize + neg - (pointer - buffer);

	memcpy(buf + neg, pointer, count);

	return count;
}

template<Character C>
template<Boolean Type>
inline constexpr U64 StringBase<C>::Format(C* buf, Type t)
{
	if (t)
	{
		memcpy(buf, TrueStr<C>, 4 * sizeof(C));
		return 4;
	}
	else
	{
		memcpy(buf, FalseStr<C>, 5 * sizeof(C));
		return 5;
	}
}

template<Character C>
template<NonStringPointer Type>
inline constexpr U64 StringBase<C>::Format(C* buf, Type t)
{
	return Format(buf, reinterpret_cast<U64>(t));
}

template<Character C>
template<Enum Type>
inline constexpr U64 StringBase<C>::Format(C* buf, Type t)
{
	if constexpr (std::is_scoped_enum_v<Type>)
	{
		return Format(buf, *t);
	}

	return Format(buf, t);
}

template<Character C>
template<Character Type>
inline constexpr U64 StringBase<C>::Format(C* buf, Type t)
{
	C c = (C)t;

	memcpy(buf, &c, sizeof(C));

	return 1;
}

template<Character C>
template<StringLiteral Type>
inline constexpr U64 StringBase<C>::Format(C* buf, Type t)
{
	using CharType = BaseType<Type>;

	U64 length = Length(t) * sizeof(CharType);

	memcpy(buf, t, length);

	return length / sizeof(CharType);
}

template<Character C>
template<StringType Type>
inline constexpr U64 StringBase<C>::Format(C* buf, Type t)
{
	U64 length = t.Size() * sizeof(Type::CharType);

	memcpy(buf, t.Data(), length);

	return length / sizeof(Type::CharType);
}

template<Character C>
template<StringViewType Type>
inline constexpr U64 StringBase<C>::Format(C* buf, Type t)
{
	U64 length = t.Size(); //TODO: templated

	memcpy(buf, t.Data(), length);

	return length;
}

template<Character C>
template<NonStringClass Type>
inline constexpr U64 StringBase<C>::Format(C* buf, Type t)
{
	return Format(buf, reinterpret_cast<U64>(&t));
}
